# CUDA支持的Makefile
# 使用方法: make -f Makefile.cuda

# 扩展信息
EXTENSION = vector
EXTVERSION = 0.8.0

# 模块名称
MODULE_big = vector

# 数据文件
DATA = $(wildcard sql/*--*--*.sql)
DATA_built = sql/$(EXTENSION)--$(EXTVERSION).sql

# 目标文件 - 包含CUDA对象文件
OBJS = \
	cuda/cuda_wrapper.o \
	cuda/indexed_gemm/indexed_gemm_v5.o \
	cuda/fusion_cos_topk/fusion_cos_topk_warpsort.o \
	cuda/l2norm/l2norm.o \
	cuda/utils.o \
	unit_tests/common/test_utils.o \
	cuda/integrate_screen/integrate_screen_separated.o \
	cuda/integrate_screen/integrate_screen_wrapper.o \
	src/bitutils.o \
	src/bitvec.o \
	src/halfutils.o \
	src/halfvec.o \
	src/hnsw.o \
	src/hnswbuild.o \
	src/hnswinsert.o \
	src/hnswscan.o \
	src/hnswutils.o \
	src/hnswvacuum.o \
	src/ivfbuild.o \
	src/ivfflat.o \
	src/ivfinsert.o \
	src/ivfkmeans.o \
	src/ivfscan.o \
	src/ivfscanbatch.o \
	src/ivfutils.o \
	src/ivfvacuum.o \
	src/sparsevec.o \
	src/vector.o \
	src/vector_batch.o \
	src/scanbatch.o

# 头文件
HEADERS = \
	src/halfvec.h \
	src/sparsevec.h \
	src/vector.h \
	src/vector_batch.h \
	src/ivfscanbatch.h

# 测试
TESTS = $(wildcard test/sql/*.sql)
REGRESS = $(patsubst test/sql/%.sql,%,$(TESTS))
REGRESS_OPTS = --inputdir=test --load-extension=$(EXTENSION)

# CUDA配置
CUDA_PATH ?= /usr/local/cuda
NVCC = $(CUDA_PATH)/bin/nvcc
CUDA_INC = -I$(CUDA_PATH)/include
CUDA_LIB = -L$(CUDA_PATH)/lib64 -lcudart -lcublas

# 编译优化标志
OPTFLAGS = -march=native

# Mac ARM doesn't always support -march=native
ifeq ($(shell uname -s), Darwin)
	ifeq ($(shell uname -p), arm)
		OPTFLAGS =
	endif
endif

# PowerPC doesn't support -march=native
ifneq ($(filter ppc64%, $(shell uname -m)), )
	OPTFLAGS =
endif

# 添加CUDA支持和优化标志
PG_CFLAGS += $(OPTFLAGS) -ftree-vectorize -fassociative-math -fno-signed-zeros -fno-trapping-math -DUSE_CUDA
PG_CPPFLAGS += -DUSE_CUDA
SHLIB_LINK += $(CUDA_LIB)

# 默认目标
all: vector.so sql/$(EXTENSION)--$(EXTVERSION).sql

sql/$(EXTENSION)--$(EXTVERSION).sql: sql/$(EXTENSION).sql
	cp $< $@

# 包含PostgreSQL构建系统
PG_CONFIG ?= pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)

# CUDA编译规则 - 必须在include $(PGXS)之后
# 使用 sm_70 架构（Tesla V100）并添加优化选项
%.o: %.cu
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -std=c++17 -O3 --use_fast_math

# C++编译规则
%.o: %.cpp
	$(CXX) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -I./cuda -std=c++17 -fPIC

# 强制覆盖CUDA对象文件的构建规则，避免.bc文件依赖
cuda/cuda_wrapper.o: cuda/cuda_wrapper.cu
	@echo "编译CUDA文件: $< -> $@"
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -std=c++17 -O3 --use_fast_math

# indexed_gemm_v5编译规则
cuda/indexed_gemm/indexed_gemm_v5.o: cuda/indexed_gemm/indexed_gemm_v5.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p cuda/indexed_gemm
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# fusion_cos_topk_warpsort编译规则
cuda/fusion_cos_topk/fusion_cos_topk_warpsort.o: cuda/fusion_cos_topk/fusion_cos_topk_warpsort.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p cuda/fusion_cos_topk
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# l2norm编译规则
cuda/l2norm/l2norm.o: cuda/l2norm/l2norm.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p cuda/l2norm
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# utils编译规则
cuda/utils.o: cuda/utils.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p cuda
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# test_utils编译规则（提供CHECK_CUDA_ERRORS宏的实现）
unit_tests/common/test_utils.o: unit_tests/common/test_utils.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p unit_tests/common
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# integrate_screen_separated编译规则（需要包含unit_tests路径以访问test_utils.cuh）
cuda/integrate_screen/integrate_screen_separated.o: cuda/integrate_screen/integrate_screen_separated.cu
	@echo "编译CUDA文件: $< -> $@"
	@mkdir -p cuda/integrate_screen
	$(NVCC) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -arch=sm_70 --expt-relaxed-constexpr -Xcompiler -fPIC -I./cuda -I./unit_tests/common -std=c++17 -O3 --use_fast_math

# integrate_screen_wrapper编译规则
cuda/integrate_screen/integrate_screen_wrapper.o: cuda/integrate_screen/integrate_screen_wrapper.cpp
	@echo "编译C++文件: $< -> $@"
	@mkdir -p cuda/integrate_screen
	$(CXX) -c $< -o $@ $(CUDA_INC) -DUSE_CUDA -I./cuda -std=c++17 -fPIC

# 强制覆盖所有.bc文件的依赖，将它们重定向到.o文件
%.bc: %.o
	@echo "跳过.bc文件生成，直接使用.o文件: $<"
	@touch $@

# 特殊处理 CUDA 文件，跳过 .bc 生成
cuda/cuda_wrapper.bc: cuda/cuda_wrapper.o
	@echo "跳过CUDA .bc文件生成"
	@touch $@

# 或者完全禁用.bc文件
.SUFFIXES: .o .c .cu
.SUFFIXES: .o .c .cu

# 检查CUDA
check_cuda:
	@echo "检查CUDA安装..."
	@if [ -d "$(CUDA_PATH)" ]; then \
		echo "CUDA路径: $(CUDA_PATH)"; \
		$(NVCC) --version; \
	else \
		echo "错误: 找不到CUDA安装路径"; \
		exit 1; \
	fi

# 检查PostgreSQL配置
check_pg:
	@echo "检查PostgreSQL配置..."
	@echo "pg_config路径: $(shell which pg_config)"
	@echo "PostgreSQL版本: $(shell $(PG_CONFIG) --version)"
	@echo "包含目录: $(shell $(PG_CONFIG) --includedir)"
	@echo "库目录: $(shell $(PG_CONFIG) --libdir)"

.PHONY: all clean install check_cuda check_pg